# Что это? Twitter EBAKA228!

![Иллюстрация](https://i.ibb.co/ZS5WgH5/image.png)
**Я не программист, поэтому костыли, тупые решения, не рациональное использование памяти и прочее не просто возможно, а точно есть в коде. Это просто БЕСПЛАТНЫЙ софт, который я сделал для себя и своих друзей и решил поделиться им**

Это софт для массового SFS в X (бывший Twitter).

Работает посредством использования двух кастомных API твиттера.

Поддерживает неограниченное количество аккаунтов.

Полезен для Onlyfans\Fansly моделей.

Этот пост я сделал для себя и решил делится им бесплатно.

### Однако, если вы хотите поддержать меня:
[Телеграм канал](https://t.me/look_im_model)

[Донат картой](https://new.donatepay.ru/@1308006)
```
USDT TRC20: TLdM77PRWwwSq6PmL1Q6K3grHyMwBqBt2D
```

```
USDT ERC20: 0xb10b6deaa6dc40a6ae13fc7bef4eb0a479f7dee8
```

```
BITCOIN: 1EELqRbFJdj2xtoUiCotHhkkVe3LJ1WeyU
```
### Нужна помощь с запуском или кастомный функционал? Нашли баги? [пишите](https://t.me/ihatemylifebutiluvmoney)

# Что умеет софт сейчас?
**Важно: на данный момент софт СОВСЕМ не работает ни с какими группами, работа происходит только в частных диалогах**

Софт **не обладает** графическим интерфейсом - только консоль, только хардкор

### Софт умеет:
- Работа исключительно через прокси
- Работа с несколькими аккаунтами
- Настройка каждого аккаунта по отдельности
- Проверять новые диалоги, ретвитить\обновлять пост который отправил собеседник
- Генерировать сообщение со своей ссылкой. Текста для сообщения полностью редактируемы (ссылку\ссылки можно указать вручную, тогда ссылка будет выбираться вручную. Если ссылка не указана, то будет отправляться ссылка на Pinned пост)
- Фильтровать твиты для ретвитинга по заданным критериям (отсутствие определенных слов, наличие скрытой-ссылки (которая открывается при нажатии на контент), язык поста)
- Фильтровать аккаунты для работы (проверка есть ли ссылка на контент платформу в описании\ссылках профиля)
- Блокировать пользователя если он заблокировал аккаунт модели
- Блокировать пользователя если он отправил не подходящий пост
- Чередовать действия из разных воркеров (например 5 действий с уже существующими диалогами и на 1 с новыми)
- Уходить в кулдаун после определенного количества выполненных действий
- Не работать с определенными пользователями
- Отправлять сообщения существующим диалогам после определенного времени
- Повторять сообщения не отвеченным диалогами
- Уходить в кулдаун если твиттер задетектил автоматику
- Скипать аккаунты без галочки
- Отправлять уведомления о критических ошибках в телеграм
- Повторные попытки запроса при проблемах с интернетом

### Пока что не умеет:
- Работа с группами
- Работа с инбоксом
- Проверять сделал ли собеседник ретвит
- Что-то еще, но не помню что

Под каждый аккаунт создается база данных для хранения времени взаимодействия с пользователем\твитом.
Твиты которые уже были в работе будут скипаться (при поиске новых пользователей для ретвитинга, чтобы не перебирать список ретвитнувших у одних и тех же постов)

База данных "плохих" пользователей общая для всех аккаунтов - то есть если один аккаунт пометил кого-то как "плохой юзер" другие аккаунты не будут с ним взаимодействовать


Это первая версия софта. Баги есть, точно есть, но я пока не знаю где.

В целом весь функционал работает успешно.

Результаты работы софта за время тестирования:
![Иллюстрация к проекту](https://i.ibb.co/tQ52pdp/image.png)
![Иллюстрация к проекту](https://i.ibb.co/7YPmtym/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/zstPh1m/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/tQ52pdp/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/pdLTRF4/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/mGS2MSn/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/61GqyNv/image.png) 

## Запуск и настройка

### Запуск
1. Клонируем проект на компьютер\сервер
2. Создаем копию файла ```settings.example.py``` и называем ее ```settings.py```
3. Редактируем настройки
4. Запускаем проект через ```python main.py``` (необходимо создать виртуальное окружение и установить зависимости) или через ```docker compose up --build``` (предварительно надо установить докер)


### Настройки
#### twttr_api_key
ключ доступа [UTools API](https://twitter.utools.me/)
#### utools_api_key
ключ доступа [Twttr API](https://rapidapi.com/twttrapi-twttrapi-default/api/twttrapi)
#### telegram_ids
список ID пользователей телеграм которым будем отсылать уведомления (не забудьте нажать Start в вашем боте)
telegram_ids = [
    1234,
    1234
]
#### telegram_bot_api_key
API-ключ телеграм бота для уведомлений

* если уведомления не нужны, то оставьте список пустым
```
telegram_ids = []
```
и ```telegram_bot_api_key``` укажите как ```None```
```
telegram_bot_api_key = None
```

#### Списки text
Вариации текстов для генерации сообщения
Каждое сообщение состоит из:

```text_for_inbox``` или ```text_for_new``` или ```text_for_exist``` или ```text_if_did_pinned```

```Ссылка```

```Ссылка```

```text_for_pinned```

```text_dont_fake```



#### text_for_inbox
 - пока что не используемый список (будет использоваться в сообщениях при обработке инбокса)
#### text_for_new
- список первой строки в сообщении для новых юзеров
#### text_for_exist
- список первой строки в сообщении для юзеров с кем было взаимодействие
#### text_if_did_pinned
- список первой строки в сообщении если был ретвитнут пиннед пост

#### text_for_pinned
- список строки ```сделай ретвит пиннед если ссылка не доступна```
#### text_dont_fake
- список строки ```я забаню тебя за фейк ретвит```
--- напоминаю что пока что софт не умеет проверять кто ретвитнул

списки ```text_for_pinned``` и ```text_dont_fake``` можно не указывать - тогда эти строки не будут добавляться

списки текстов вынесены в отдельные переменные для удобства, но вы можете указывать их прямо при объявлении объекта настроек.
можно создать разные списки с текстами (дайте им разные названия и потом просто укажите нужный список в нужном объекте настроек/просто пропишите список при объявлении настройки)

### Создание объекта настройки
создаем переменную с любым названием в которой объявляем экземпляр класса ```Settings```

```
settings = Settings()
```

Можно создать разные настройки (для использования разных настроек у разных аккаунтов)

Указываем необходимые переменнеые настроек (смотрите как это сделано в файле ```settings.example.py```)

У любого объекта настроек есть стандартные значения, если стандартное значение подходит вам - можно не добавлять эту настройку при создании объекта класса ```Settings()```

Список возможных настроек и их стандартные значения:
#### start_tweets
- список айдишников стартовых твитов (с которых будут парситься новые юзеры при старте программы, например если на аккаунте еще нет диалогов и не откуда брать новые твиты для парсинга)
- по умолчанию список пуст

#### links
- список ссылок для промоутинга
- по умолчанию список пуст - в таком случае софт будет получать ссылку на пиннед пост

#### ban_if_bad_post
- банить пользователя если пост не прошел проверку (скрытая реклама\язык\запретные слова)
- По умолчанию True

#### ban_if_user_banned_you
- банить юзера если он забанил наш аккаунт
- по умолчанию True

#### skip_after_empty_pages
- через сколько страниц без новых сообщений начинать работу с уже существующими диалогами снова (софт проверяем диалоги постранично от новых к старым, если на странице нет диалогов подходящие под наши критерии - страница помечается пустой. если ```skip_readed``` установлено как ```False``` то скорее всего софт будет проходить по ВСЕМ существующим диалогам и начинать обработку DM только после обработки всех диалогов.
- пол умолчанию 50

#### actions_steps
- сколько действий с уже существующими диалогами выполнить перед выполения действия с новым пользователем 
- по умолчанию 5

#### cooldown_every_steps
- раз в сколько действий уходим в кулдаун
- по умолчанию 100

#### followers_to_work
- сколько у юзера должно быть подписчиков чтобы мы работали с ним
- по умолчанию 15000

#### work_with_not_blue_verified
- работать ли с пользователями без галочки
- по умолчанию ```True```

#### work_if_not_sure_that_its_model
- работать ли с пользователем если мы не смогли убедиться что это модель
- по умолчанию ```False```

проверка модель ли это происходит по наличию одного из следующих слов в описании\ссылках профиля:
```
MODEL_MARKERS = [
    "onlyfans",
    "of.com",
    "fansly",
    "fans.ly",
    "justfor.fans",
    "just for fans"
    "jff",
    "j4f"
    "t.me",
    "http://t.me",
    "https://t.me",
    "content creator",
    "collabs",
    "model",
    "adult",
    "allmylinks",
    "only fans",
    "linktree",
    "linktr.ee",
    "privacy.com.br",
    "fansone.co",
    "chaturbate",
    "stripchat",
]
```

#### min_bookmark_count_to_work
- сколько раз пост должен быть добавлен в bookmark, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_favorite_count_to_work
- сколько раз пост должен быть добавлен в фаворитс, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_reply_count_to_work
- сколько на пост должно быть ответов, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_retweet_count_to_work
- сколько у поста должно быть ретвитов, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_tweet_views_to_work
- сколько у поста должно быть просмотров, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### banned_words_in_tweet
- список слов которых не должно быть в тексте поста
- по умолчанию пуст

#### banned_words_in_tweet
- список кодов языков, если пост на этом языке, то он не подходит
- по умолчанию пуст

#### ignor_user_ids
- список айдишников юзеров с кем мы НЕ будем работать (например, диалоги с мемберами)
- по умолчанию пуст

#### skip_hidden_ads
- работать ли с постами со скрытой рекламой (ссылка открывающаяся при нажатии на контент)
- по умолчанию ```True```

#### check_retweets
- проверять ли сделал ли юзер ретвит
- по умолчанию ```True```
- на данный момент не работает

#### skip_readed
- пропускать ли диалог в работе с существующими диалогами, если нет непрочитанных сообщений
- по умолчанию ```True```


#### skip_groups
- пропускать ли группы
- по умолчанию ```True```
- на данный момент не работает

#### skip_inbox
- пропускать ли диалоги из инбокса
- по умолчанию ```True```
- на данный момент не работает

#### text_for_inbox, text_for_pinned, text_dont_fake, text_for_new, text_for_exist, text_for_no_tweet, text_if_did_pinned
- описанные выше списки строк
- по умолчанию списки пусты. если список пуст, то используется стандартная строка

#### minutes_before_next_interaction_with_exist
- сколько минут должно пройти перед новым взаимодействием с существующим диалогом
- по умолчанию 60

#### minutes_before_attempt_for_new_dm
- сколько минут должно пройти с последнего взаимодействия, если юзер не ответил
- по умолчанию 10080 (7 дней)

#### min_actions_delay
- минимальная задержка в секундах перед "большими" действиями (запрос новый страницы диалогов\списка ретвитнувших, отправка сообщения, бан юзера)
- по умолчанию 10

#### max_actions_delay
- максимальная задержка в секундах перед "большими" действиями (запрос новый страницы диалогов\списка ретвитнувших, отправка сообщения, бан юзера)
- по умолчанию 20

#### min_small_actions_delay
- минимальная задержка в секундах перед "маленькими" действиями (ретвит, анретвит)
- по умолчанию 5

#### max_small_actions_delay
- максимальная задержка в секундах перед "маленькими" действиями (ретвит, анретвит)
- по умолчанию 10

#### cooldown_seconds
- время кулдауна в секундах
- по умолчанию 900

#### if_detected_cooldown_seconds
- время кулдауна при детекте работы через софт
- по умолчанию 900

### Создание объекта пользователя
создаем переменную с любым названием в которой объявляем экземпляр класса ```Account``` и указываем его настройки

```
account = Account(
    "Прокси без протокола",
    "screen_name",
    "сессия twttr_api",
    "auth_token",
    "#00cec9",
    settings
)
```

#### Прокси
Указываем прокси в формате ```Логин:пароль@IP:Порт```

Префикс ```https://``` и ```http://``` указывать НЕ нужно (но сам прокси должен работать с обоими протоколами, так как апишники юзают разные протоколы)

#### screen_name
Юзернейм пользователя без @

#### сессия twttr_api
Сессия полученная через Twttr Api.

Как получить сессию:
1. [Идем сюда](https://rapidapi.com/twttrapi-twttrapi-default/api/twttrapi/playground/apiendpoint_46a24065-71c7-42df-b63f-128026290e40), в разделе ```Headers``` указываем прокси, в разделе ```Body``` указываем данные для входа
2. Если получили в ответе ```session``` - это то что надо
3. Если в ответе получили ```login_data``` - [Идем сюда](https://rapidapi.com/twttrapi-twttrapi-default/api/twttrapi/playground/apiendpoint_f1cbc18d-e6cb-422c-b955-09655f22c5f3), указываем прокси, в ```Body``` вставляем значение ```login_data```, а в ```response``` код (из приложения двухфакторки\с почты) или номер телефона, или email (если вы получили ```login_data``` в пункте 2, то там также будет указано сообщение от твиттера в котором будет сказано что конкретно указать)

#### auth_token
Токен из куки.
[Вот инструкция по получению](https://x.com/good6_api/status/1812496182213845482)
ct0 указывать не нужно - он получается автоматически при запуске софта

#### Цвет
После ```auth_token``` указываем цвет в формате hex - таким цветом ник аккаунта будет отмечаться в логах

#### Настройки
После цвета указываем название переменной в которой лежит созданный нами объект настроек

### Указание аккаунтов для работы
создаем список с названием ```accounts_list``` в котором перечисляем созданные нами объекты аккаунтов
```
accounts_list = [
    account
]
```

Это софт для массового SFS в X (бывший Twitter).

Работает посредством использования двух кастомных API твиттера.

Поддерживает неограниченное количество аккаунтов.

Полезен для Onlyfans\Fansly моделей.

Этот пост я сделал для себя и решил делится им бесплатно.

### Однако, если вы хотите поддержать меня:
[Телеграм канал](https://t.me/look_im_model)

[Донат картой](https://new.donatepay.ru/@1308006)
```
USDT TRC20: TLdM77PRWwwSq6PmL1Q6K3grHyMwBqBt2D
```

```
USDT ERC20: 0xb10b6deaa6dc40a6ae13fc7bef4eb0a479f7dee8
```

```
BITCOIN: 1EELqRbFJdj2xtoUiCotHhkkVe3LJ1WeyU
```
### Нужна помощь с запуском или кастомный функционал? Нашли баги? [пишите](https://t.me/ihatemylifebutiluvmoney)

# Что умеет софт сейчас?
**Важно: на данный момент софт СОВСЕМ не работает ни с какими группами, работа происходит только в частных диалогах**

Софт **не обладает** графическим интерфейсом - только консоль, только хардкор

### Софт умеет:
- Работа исключительно через прокси
- Работа с несколькими аккаунтами
- Настройка каждого аккаунта по отдельности
- Проверять новые диалоги, ретвитить\обновлять пост который отправил собеседник
- Генерировать сообщение со своей ссылкой. Текста для сообщения полностью редактируемы (ссылку\ссылки можно указать вручную, тогда ссылка будет выбираться вручную. Если ссылка не указана, то будет отправляться ссылка на Pinned пост)
- Фильтровать твиты для ретвитинга по заданным критериям (отсутствие определенных слов, наличие скрытой-ссылки (которая открывается при нажатии на контент), язык поста)
- Фильтровать аккаунты для работы (проверка есть ли ссылка на контент платформу в описании\ссылках профиля)
- Блокировать пользователя если он заблокировал аккаунт модели
- Блокировать пользователя если он отправил не подходящий пост
- Чередовать действия из разных воркеров (например 5 действий с уже существующими диалогами и на 1 с новыми)
- Уходить в кулдаун после определенного количества выполненных действий
- Не работать с определенными пользователями
- Отправлять сообщения существующим диалогам после определенного времени
- Повторять сообщения не отвеченным диалогами
- Уходить в кулдаун если твиттер задетектил автоматику
- Скипать аккаунты без галочки
- Отправлять уведомления о критических ошибках в телеграм
- Повторные попытки запроса при проблемах с интернетом

### Пока что не умеет:
- Работа с группами
- Работа с инбоксом
- Проверять сделал ли собеседник ретвит
- Что-то еще, но не помню что

Под каждый аккаунт создается база данных для хранения времени взаимодействия с пользователем\твитом.
Твиты которые уже были в работе будут скипаться (при поиске новых пользователей для ретвитинга, чтобы не перебирать список ретвитнувших у одних и тех же постов)

База данных "плохих" пользователей общая для всех аккаунтов - то есть если один аккаунт пометил кого-то как "плохой юзер" другие аккаунты не будут с ним взаимодействовать


Это первая версия софта. Баги есть, точно есть, но я пока не знаю где.

В целом весь функционал работает успешно.

Результаты работы софта за время тестирования:
![Иллюстрация к проекту](https://i.ibb.co/tQ52pdp/image.png)
![Иллюстрация к проекту](https://i.ibb.co/7YPmtym/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/zstPh1m/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/tQ52pdp/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/pdLTRF4/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/mGS2MSn/image.png) 
![Иллюстрация к проекту](https://i.ibb.co/61GqyNv/image.png) 

## Запуск и настройка

### Запуск
1. Клонируем проект на компьютер\сервер
2. Создаем копию файла ```settings.example.py``` и называем ее ```settings.py```
3. Редактируем настройки
4. Запускаем проект через ```python main.py``` (необходимо создать виртуальное окружение и установить зависимости) или через ```docker compose up --build``` (предварительно надо установить докер)


### Настройки
#### twttr_api_key
ключ доступа [UTools API](https://twitter.utools.me/)
#### utools_api_key
ключ доступа [Twttr API](https://rapidapi.com/twttrapi-twttrapi-default/api/twttrapi)
#### telegram_ids
список ID пользователей телеграм которым будем отсылать уведомления (не забудьте нажать Start в вашем боте)
telegram_ids = [
    1234,
    1234
]
#### telegram_bot_api_key
API-ключ телеграм бота для уведомлений

* если уведомления не нужны, то оставьте список пустым
```
telegram_ids = []
```
и ```telegram_bot_api_key``` укажите как ```None```
```
telegram_bot_api_key = None
```

#### Списки text
Вариации текстов для генерации сообщения
Каждое сообщение состоит из:

```text_for_inbox``` или ```text_for_new``` или ```text_for_exist``` или ```text_if_did_pinned```

```Ссылка```

```Ссылка```

```text_for_pinned```

```text_dont_fake```



#### text_for_inbox
 - пока что не используемый список (будет использоваться в сообщениях при обработке инбокса)
#### text_for_new
- список первой строки в сообщении для новых юзеров
#### text_for_exist
- список первой строки в сообщении для юзеров с кем было взаимодействие
#### text_if_did_pinned
- список первой строки в сообщении если был ретвитнут пиннед пост

#### text_for_pinned
- список строки ```сделай ретвит пиннед если ссылка не доступна```
#### text_dont_fake
- список строки ```я забаню тебя за фейк ретвит```
--- напоминаю что пока что софт не умеет проверять кто ретвитнул

списки ```text_for_pinned``` и ```text_dont_fake``` можно не указывать - тогда эти строки не будут добавляться

списки текстов вынесены в отдельные переменные для удобства, но вы можете указывать их прямо при объявлении объекта настроек.
можно создать разные списки с текстами (дайте им разные названия и потом просто укажите нужный список в нужном объекте настроек/просто пропишите список при объявлении настройки)

### Создание объекта настройки
создаем переменную с любым названием в которой объявляем экземпляр класса ```Settings```

```
settings = Settings()
```

Можно создать разные настройки (для использования разных настроек у разных аккаунтов)

Указываем необходимые переменнеые настроек (смотрите как это сделано в файле ```settings.example.py```)

У любого объекта настроек есть стандартные значения, если стандартное значение подходит вам - можно не добавлять эту настройку при создании объекта класса ```Settings()```

Список возможных настроек и их стандартные значения:
#### start_tweets
- список айдишников стартовых твитов (с которых будут парситься новые юзеры при старте программы, например если на аккаунте еще нет диалогов и не откуда брать новые твиты для парсинга)
- по умолчанию список пуст

#### links
- список ссылок для промоутинга
- по умолчанию список пуст - в таком случае софт будет получать ссылку на пиннед пост

#### ban_if_bad_post
- банить пользователя если пост не прошел проверку (скрытая реклама\язык\запретные слова)
- По умолчанию True

#### ban_if_user_banned_you
- банить юзера если он забанил наш аккаунт
- по умолчанию True

#### skip_after_empty_pages
- через сколько страниц без новых сообщений начинать работу с уже существующими диалогами снова (софт проверяем диалоги постранично от новых к старым, если на странице нет диалогов подходящие под наши критерии - страница помечается пустой. если ```skip_readed``` установлено как ```False``` то скорее всего софт будет проходить по ВСЕМ существующим диалогам и начинать обработку DM только после обработки всех диалогов.
- пол умолчанию 50

#### actions_steps
- сколько действий с уже существующими диалогами выполнить перед выполения действия с новым пользователем 
- по умолчанию 5

#### cooldown_every_steps
- раз в сколько действий уходим в кулдаун
- по умолчанию 100

#### followers_to_work
- сколько у юзера должно быть подписчиков чтобы мы работали с ним
- по умолчанию 15000

#### work_with_not_blue_verified
- работать ли с пользователями без галочки
- по умолчанию ```True```

#### work_if_not_sure_that_its_model
- работать ли с пользователем если мы не смогли убедиться что это модель
- по умолчанию ```False```

проверка модель ли это происходит по наличию одного из следующих слов в описании\ссылках профиля:
```
MODEL_MARKERS = [
    "onlyfans",
    "of.com",
    "fansly",
    "fans.ly",
    "justfor.fans",
    "just for fans"
    "jff",
    "j4f"
    "t.me",
    "http://t.me",
    "https://t.me",
    "content creator",
    "collabs",
    "model",
    "adult",
    "allmylinks",
    "only fans",
    "linktree",
    "linktr.ee",
    "privacy.com.br",
    "fansone.co",
    "chaturbate",
    "stripchat",
]
```

#### min_bookmark_count_to_work
- сколько раз пост должен быть добавлен в bookmark, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_favorite_count_to_work
- сколько раз пост должен быть добавлен в фаворитс, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_reply_count_to_work
- сколько на пост должно быть ответов, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_retweet_count_to_work
- сколько у поста должно быть ретвитов, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### min_tweet_views_to_work
- сколько у поста должно быть просмотров, чтобы мы начали искать в нем новых моделей
- по умолчанию 0

#### banned_words_in_tweet
- список слов которых не должно быть в тексте поста
- по умолчанию пуст

#### banned_words_in_tweet
- список кодов языков, если пост на этом языке, то он не подходит
- по умолчанию пуст

#### ignor_user_ids
- список айдишников юзеров с кем мы НЕ будем работать (например, диалоги с мемберами)
- по умолчанию пуст

#### skip_hidden_ads
- работать ли с постами со скрытой рекламой (ссылка открывающаяся при нажатии на контент)
- по умолчанию ```True```

#### check_retweets
- проверять ли сделал ли юзер ретвит
- по умолчанию ```True```
- на данный момент не работает

#### skip_readed
- пропускать ли диалог в работе с существующими диалогами, если нет непрочитанных сообщений
- по умолчанию ```True```


#### skip_groups
- пропускать ли группы
- по умолчанию ```True```
- на данный момент не работает

#### skip_inbox
- пропускать ли диалоги из инбокса
- по умолчанию ```True```
- на данный момент не работает

#### text_for_inbox, text_for_pinned, text_dont_fake, text_for_new, text_for_exist, text_for_no_tweet, text_if_did_pinned
- описанные выше списки строк
- по умолчанию списки пусты. если список пуст, то используется стандартная строка

#### minutes_before_next_interaction_with_exist
- сколько минут должно пройти перед новым взаимодействием с существующим диалогом
- по умолчанию 60

#### minutes_before_attempt_for_new_dm
- сколько минут должно пройти с последнего взаимодействия, если юзер не ответил
- по умолчанию 10080 (7 дней)

#### min_actions_delay
- минимальная задержка в секундах перед "большими" действиями (запрос новый страницы диалогов\списка ретвитнувших, отправка сообщения, бан юзера)
- по умолчанию 10

#### max_actions_delay
- максимальная задержка в секундах перед "большими" действиями (запрос новый страницы диалогов\списка ретвитнувших, отправка сообщения, бан юзера)
- по умолчанию 20

#### min_small_actions_delay
- минимальная задержка в секундах перед "маленькими" действиями (ретвит, анретвит)
- по умолчанию 5

#### max_small_actions_delay
- максимальная задержка в секундах перед "маленькими" действиями (ретвит, анретвит)
- по умолчанию 10

#### cooldown_seconds
- время кулдауна в секундах
- по умолчанию 900

#### if_detected_cooldown_seconds
- время кулдауна при детекте работы через софт
- по умолчанию 900

### Создание объекта пользователя
создаем переменную с любым названием в которой объявляем экземпляр класса ```Account``` и указываем его настройки

```
account = Account(
    "Прокси без протокола",
    "screen_name",
    "сессия twttr_api",
    "auth_token",
    "#00cec9",
    settings
)
```

#### Прокси
Указываем прокси в формате ```Логин:пароль@IP:Порт```

Префикс ```https://``` и ```http://``` указывать НЕ нужно (но сам прокси должен работать с обоими протоколами, так как апишники юзают разные протоколы)

#### screen_name
Юзернейм пользователя без @

#### сессия twttr_api
Сессия полученная через Twttr Api.

Как получить сессию:
1. [Идем сюда](https://rapidapi.com/twttrapi-twttrapi-default/api/twttrapi/playground/apiendpoint_46a24065-71c7-42df-b63f-128026290e40), в разделе ```Headers``` указываем прокси, в разделе ```Body``` указываем данные для входа
2. Если получили в ответе ```session``` - это то что надо
3. Если в ответе получили ```login_data``` - [Идем сюда](https://rapidapi.com/twttrapi-twttrapi-default/api/twttrapi/playground/apiendpoint_f1cbc18d-e6cb-422c-b955-09655f22c5f3), указываем прокси, в ```Body``` вставляем значение ```login_data```, а в ```response``` код (из приложения двухфакторки\с почты) или номер телефона, или email (если вы получили ```login_data``` в пункте 2, то там также будет указано сообщение от твиттера в котором будет сказано что конкретно указать)

#### auth_token
Токен из куки.
[Вот инструкция по получению](https://x.com/good6_api/status/1812496182213845482)
ct0 указывать не нужно - он получается автоматически при запуске софта

#### Цвет
После ```auth_token``` указываем цвет в формате hex - таким цветом ник аккаунта будет отмечаться в логах

#### Настройки
После цвета указываем название переменной в которой лежит созданный нами объект настроек

### Указание аккаунтов для работы
создаем список с названием ```accounts_list``` в котором перечисляем созданные нами объекты аккаунтов
```
accounts_list = [
    account
]
```